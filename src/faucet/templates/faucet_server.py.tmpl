#!/usr/bin/env python3
import json
import subprocess
from http.server import HTTPServer, BaseHTTPRequestHandler
import os, shutil, re

CHAIN_ID = os.environ.get("CHAIN_ID", "thorchain")
NODE_URL = os.environ.get("NODE_URL", "http://localhost:26657")
KEY_NAME = os.environ.get("KEY_NAME", "faucet")
KEYRING_BACKEND = os.environ.get("KEYRING_BACKEND", "test")
PORT = int(os.environ.get("PORT", "8090"))
TRANSFER_AMOUNT = int(os.environ.get("TRANSFER_AMOUNT", "10000000000000"))
THORNODE_BIN = os.environ.get("THORNODE_BIN") or shutil.which("thornode") or next((p for p in ["/usr/local/bin/thornode","/usr/bin/thornode","/bin/thornode","/sbin/thornode","/usr/sbin/thornode"] if os.path.isfile(p) and os.access(p, os.X_OK)), None)

class Handler(BaseHTTPRequestHandler):
    def end_headers(self):
        # Completely permissive CORS
        self.send_header("Access-Control-Allow-Origin", "*")
        self.send_header("Access-Control-Allow-Methods", "*")
        self.send_header("Access-Control-Allow-Headers", "*")
        self.send_header("Access-Control-Allow-Credentials", "true")
        super().end_headers()

    def do_OPTIONS(self):
        # Respond to all preflight requests
        self.send_response(204)
        self.end_headers()

    def _send(self, code, body):
        self.send_response(code)
        self.send_header("Content-Type", "application/json")
        self.end_headers()
        self.wfile.write(json.dumps(body).encode())

    def do_POST(self):
        if self.path != "/fund":
            self._send(404, {"error":"not found"})
            return
        try:
            if not THORNODE_BIN:
                self._send(500, {"error":"thornode binary not found"})
                return
            length = int(self.headers.get("Content-Length","0"))
            data = json.loads(self.rfile.read(length) or "{}")
            address = data.get("address")

            # Accept amount from request OR use default
            amount = data.get("amount")
            if amount is None:
                amount = TRANSFER_AMOUNT
            else:
                # Validate it's a positive integer
                if not isinstance(amount, int) or amount <= 0:
                    self._send(400, {"error": "amount must be a positive integer"})
                    return

            denom = data.get("denom", "rune")
            if not address:
                self._send(400, {"error":"address required"})
                return
            if not isinstance(denom, str) or not denom:
                self._send(400, {"error":"denom must be non-empty string"})
                return
            coin = f"{amount}{denom}"
            cmd = [
                THORNODE_BIN,"tx","bank","send", KEY_NAME, address, coin,
                "--chain-id", CHAIN_ID,
                "--node", NODE_URL,
                "--keyring-backend", KEYRING_BACKEND,
                "--gas","auto",
                "--gas-adjustment","1.3",
                "--fees","500000rune",
                "-y","--broadcast-mode","sync"
            ]
            res = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            if res.returncode != 0:
                self._send(500, {"error":"tx failed","stderr":res.stderr})
                return

            # Parse tx hash from the thornode CLI output (thorchain prints 'txhash: ...')
            txhash = None
            match = re.search(r'txhash:\s*([A-Fa-f0-9]+)', res.stdout)
            if match:
                txhash = match.group(1)

            # Return clean response matching Ethereum-style format
            self._send(200, {
                "message": "Native transfer successful",
                "txHash": txhash,
                "amount": amount,
                "denom": denom,
                "ok": True,
                "rawOutput": res.stdout  # Keep raw output for debugging
            })
        except Exception as e:
            self._send(500, {"error":str(e)})

if __name__ == "__main__":
    try:
        if THORNODE_BIN:
            check = subprocess.run(
                [THORNODE_BIN,"keys","show",KEY_NAME,"--keyring-backend",KEYRING_BACKEND],
                stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True
            )
            if check.returncode != 0:
                mn = open(os.environ.get("MNEMONIC_PATH", "/tmp/mnemonic/mnemonic.txt"),"r").read().strip()
                subprocess.run(
                    [THORNODE_BIN,"keys","add",KEY_NAME,"--recover","--keyring-backend",KEYRING_BACKEND],
                    input=mn + "\n",
                    stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True
                )
    except Exception:
        pass
    server = HTTPServer(("0.0.0.0", PORT), Handler)
    server.serve_forever()
